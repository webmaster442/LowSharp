using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Text;

using Iced.Intel;

using Microsoft.Diagnostics.Runtime;

using Decoder = Iced.Intel.Decoder;

namespace Lowsharp.Server.Lowering.Decompilers;

/// <summary>
/// Provides an extension method to dump the ASM generated by the current JIT of a <see cref="MethodInfo"/>.
/// </summary>
internal static class JitBuddy
{
    /// <summary>
    /// Disassemble the method.
    /// </summary>
    /// <param name="method">A method to disassemble</param>
    /// <param name="builder">The builder to receive the method ASM</param>
    public static void ToAsm(this MethodInfo method, StringBuilder builder, Formatter formatter)
    {
        using (var dataTarget = DataTarget.AttachToProcess(Environment.ProcessId, false))
        {
            var clrVersion = dataTarget.ClrVersions.First();
            var runtime = clrVersion.CreateRuntime();
            dataTarget.DataReader.FlushCachedData();

            // Make sure the method is being Jitted
            RuntimeHelpers.PrepareMethod(method.MethodHandle);

            // Get the handle from clrmd
            ClrMethod? clrmdMethodHandle = runtime.GetMethodByHandle((ulong)method.MethodHandle.Value.ToInt64());

            if (clrmdMethodHandle == null || clrmdMethodHandle.NativeCode == 0)
                throw new InvalidOperationException($"Unable to disassemble method `{method}`");

            //HResult result = runtime.DacLibrary.SOSDacInterface.GetCodeHeaderData(clrmdMethodHandle.NativeCode, out CodeHeaderData codeHeaderData);

            //ClrMethod? clrmd = runtime.GetMethodByHandle(clrmdMethodHandle.NativeCode);


            var codePtr = clrmdMethodHandle.HotColdInfo.HotStart;
            var codeSize = clrmdMethodHandle.HotColdInfo.HotSize;

            if (codePtr == 0 || codeSize == 0)
            {
                return;
            }

            // Disassemble with Iced
            DecodeMethod(new IntPtr((long)codePtr), codeSize, builder, formatter);
        }
    }

    private static void DecodeMethod(IntPtr ptr, uint size, StringBuilder builder, Formatter formatter)
    {
        // You can also pass in a hex string, eg. "90 91 929394", or you can use your own CodeReader
        // reading data from a file or memory etc.
        var codeReader = new UnmanagedCodeReader(ptr, size);
        var decoder = Decoder.Create(IntPtr.Size * 8, codeReader);
        decoder.IP = (ulong)ptr.ToInt64();
        ulong endRip = decoder.IP + (uint)size;

        // This list is faster than List<Instruction> since it uses refs to the Instructions
        // instead of copying them (each Instruction is 32 bytes in size). It has a ref indexer,
        // and a ref iterator. Add() uses 'in' (ref readonly).
        var instructions = new InstructionList();
        while (decoder.IP < endRip)
        {
            // The method allocates an uninitialized element at the end of the list and
            // returns a reference to it which is initialized by Decode().
            decoder.Decode(out instructions.AllocUninitializedElement());
        }

        var output = new StringOutput();
        // Use InstructionList's ref iterator (C# 7.3) to prevent copying 32 bytes every iteration
        foreach (ref var instr in instructions)
        {
            // Don't use instr.ToString(), it allocates more, uses masm syntax and default options
            formatter.Format(in instr, output);
            builder.AppendLine($"{instr.IP:X16} {output.ToStringAndReset()}");
        }
    }

    private class UnmanagedCodeReader : CodeReader
    {
        private readonly IntPtr _ptr;
        private readonly uint _size;
        private uint _offset;

        public UnmanagedCodeReader(IntPtr ptr, uint size)
        {
            _ptr = ptr;
            _size = size;
        }

        public override int ReadByte()
        {
            if (_offset >= _size)
            {
                return -1;
            }

            var offset = _offset;
            _offset++;
            return Marshal.ReadByte(_ptr, (int)offset);
        }
    }
}